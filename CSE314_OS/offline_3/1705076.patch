diff --git a/Makefile b/Makefile
index 09d790c..876306e 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,9 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+    _dummy\
+    _ps\
+    _schedular_test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -250,6 +253,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+    dummy.c ps.c schedular_test.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/defs.h b/defs.h
index 82fb982..bee40c7 100644
--- a/defs.h
+++ b/defs.h
@@ -9,6 +9,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct pstat;
 
 // bio.c
 void            binit(void);
@@ -120,6 +121,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            getpinfo(struct pstat*);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/dummy.c b/dummy.c
new file mode 100644
index 0000000..2c8a911
--- /dev/null
+++ b/dummy.c
@@ -0,0 +1,10 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+    printf(1, "dummy program\n"); 
+    exit();
+}
diff --git a/proc.c b/proc.c
index 806b1b1..596242b 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,15 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "pstat.h"
+
+
+uint rand_state = 0xABC;
+uint random() {
+    uint bit = (rand_state ^ (rand_state >> 3) ^ (rand_state >> 12) ^ (rand_state >> 14) ^ (rand_state >> 15)) & 1;
+    rand_state = (rand_state >> 1) | (bit << 15);
+    return rand_state;
+}
 
 struct {
   struct spinlock lock;
@@ -149,6 +158,8 @@ userinit(void)
   acquire(&ptable.lock);
 
   p->state = RUNNABLE;
+  p->ticks = 0;
+  p->tickets = 1;
 
   release(&ptable.lock);
 }
@@ -216,6 +227,9 @@ fork(void)
 
   np->state = RUNNABLE;
 
+  np->ticks = 0;
+  np->tickets = curproc->tickets;
+
   release(&ptable.lock);
 
   return pid;
@@ -311,17 +325,8 @@ wait(void)
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
-{
+__attribute__((noreturn))
+void round_robin(void) {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
@@ -342,6 +347,7 @@ scheduler(void)
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
+      p->ticks++;
 
       swtch(&(c->scheduler), p->context);
       switchkvm();
@@ -353,6 +359,82 @@ scheduler(void)
     release(&ptable.lock);
 
   }
+ 
+}
+
+__attribute__((noreturn))
+void lottery_ticket(void){
+    struct proc *p;
+    struct cpu *c = mycpu();
+    c->proc = 0;
+
+    for(;;){
+        sti();
+
+        acquire(&ptable.lock);
+        
+
+        int total = 0;
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+            if(p->state != RUNNABLE && p->state != RUNNING)
+                continue;
+            total += p->tickets;
+        }
+
+        int r = 1;
+        if(total > 0) 
+            r = random() % total + 1;
+        //int copy_r = r;
+
+        
+
+        int found = 0;
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+            if(p->state != RUNNABLE && p->state != RUNNING)
+                continue;
+
+            r -= p->tickets;
+
+            if(r <= 0){
+                found = 1;
+                break;
+            }
+        }
+        
+        //if(found)
+        //    cprintf("sched: %d %d %d\n", p->pid, total, copy_r);
+
+        if(found && p->state != RUNNING){
+            c->proc = p;
+            switchuvm(p);
+            p->state = RUNNING;
+            p->ticks++;
+
+            swtch(&(c->scheduler), p->context);
+            switchkvm();
+
+            c->proc = 0;
+        }
+        else if(found && p->state == RUNNING)
+            p->ticks++;
+
+        release(&ptable.lock);
+    }
+}
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+    //round_robin();
+    lottery_ticket();
 }
 
 // Enter scheduler.  Must hold only ptable.lock
@@ -532,3 +614,21 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+// TODO change ticks according to scheduling
+void
+getpinfo(struct pstat* info){
+    acquire(&ptable.lock);
+    for(int i = 0; i<NPROC; i++){
+        if(ptable.proc[i].state == UNUSED){
+            info->inuse[i] = 0;
+        }
+        else{
+            info->inuse[i] = 1;
+            info->pid[i] = ptable.proc[i].pid;
+            info->ticks[i] = ptable.proc[i].ticks;
+            info->tickets[i] = ptable.proc[i].tickets;
+        }
+    }
+    release(&ptable.lock);
+}
diff --git a/proc.h b/proc.h
index 1647114..24de13f 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int ticks;                   // ticks = number of times it has been scheduled
+  int tickets;                 // tickets for lottery scheduling
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/ps.c b/ps.c
new file mode 100644
index 0000000..8990fba
--- /dev/null
+++ b/ps.c
@@ -0,0 +1,25 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#include "pstat.h"
+
+void ps(){
+    struct pstat info; 
+    getpinfo(&info);
+
+
+    printf(1, "pid tickets ticks\n");
+    for(int i = 0; i<NPROC; i++){
+        if(info.inuse[i]){
+            printf(1, "%d %d %d\n", info.pid[i], info.tickets[i], info.ticks[i]);
+        }
+    }
+}
+
+int
+main(int argc, char *argv[])
+{
+    ps();
+    exit();
+}
diff --git a/pstat.h b/pstat.h
new file mode 100644
index 0000000..b3d53a0
--- /dev/null
+++ b/pstat.h
@@ -0,0 +1,13 @@
+#ifndef _PSTAT_H_
+#define _PSTAT_H_
+
+#include "param.h"
+
+struct pstat {
+    int inuse[NPROC]; // whether this slot of the process table is in use (1 or 0)
+    int tickets[NPROC]; // the number of tickets this process has
+    int pid[NPROC]; // the pid of each process
+    int ticks[NPROC]; // the number of ticks each process has accumulated
+};
+
+#endif // _PSTAT_H_
diff --git a/schedular_test.c b/schedular_test.c
new file mode 100644
index 0000000..4c6b394
--- /dev/null
+++ b/schedular_test.c
@@ -0,0 +1,60 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "pstat.h"
+
+const int child_cnt = 20;
+
+__attribute__((noreturn))
+void function() {
+    while(1){
+        __asm__("");
+    }
+}
+
+int
+main(int argc, char *argv[])
+{
+    int pids[child_cnt];
+
+    for(int i = 0; i<child_cnt; i++){
+        int p;
+        if((p = fork()) == 0){
+            if(i >= 15)
+                settickets(2);
+            else
+                settickets(1);
+            function();
+        }
+        else if(p < -1){
+            printf(1, "oh no \n");
+        }
+        else {
+            pids[i] = p;
+        }
+    }
+
+
+    sleep(500);
+
+    struct pstat info;
+    getpinfo(&info);
+
+    for(int i = 0; i<child_cnt; i++){
+        for(int j = 0; j<NPROC; j++){
+            if(info.inuse[j] == 1 && info.pid[j] == pids[i]){
+                printf(1, "%d %d %d\n", info.pid[j], info.tickets[j], info.ticks[j]);
+                break;
+            }
+        }
+    }
+
+    for(int i = 0; i<child_cnt; i++){
+        kill(pids[i]);
+    }
+
+    for(int i = 0; i<child_cnt; i++){
+        wait();
+    }
+    exit();
+}
diff --git a/syscall.c b/syscall.c
index ee85261..324ab33 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_settickets(void);    
+extern int sys_getpinfo(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_settickets] sys_settickets,
+[SYS_getpinfo] sys_getpinfo,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..7926b7f 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_settickets 22
+#define SYS_getpinfo 23
diff --git a/sysproc.c b/sysproc.c
index 0686d29..e5b0d0c 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -6,6 +6,7 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "pstat.h"
 
 int
 sys_fork(void)
@@ -89,3 +90,29 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_settickets(void)
+{
+    int ticketcnt;
+
+    if(argint(0, &ticketcnt) < 0)
+        return -1;
+    if(ticketcnt < 0)
+        return -1;
+    // TODO might need to lock ptable
+    myproc()->tickets = ticketcnt;
+
+    return 0;
+}
+
+int 
+sys_getpinfo(void)
+{
+    struct pstat* info;
+    if(argptr(0, (void*) &info, sizeof(struct pstat) < 0))
+        return -1;
+
+    getpinfo(info);
+    return 0;
+}
diff --git a/ulib.c b/ulib.c
index 8e1e1a2..82ad7b7 100644
--- a/ulib.c
+++ b/ulib.c
@@ -4,6 +4,7 @@
 #include "user.h"
 #include "x86.h"
 
+
 char*
 strcpy(char *s, const char *t)
 {
diff --git a/user.h b/user.h
index 4f99c52..7f7df9c 100644
--- a/user.h
+++ b/user.h
@@ -1,5 +1,6 @@
 struct stat;
 struct rtcdate;
+struct pstat;
 
 // system calls
 int fork(void);
@@ -23,6 +24,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int settickets(int);
+int getpinfo(struct pstat*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..bce13c0 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(settickets)
+SYSCALL(getpinfo)
