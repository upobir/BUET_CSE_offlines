diff --git a/Makefile b/Makefile
index 09d790c..91052b0 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,7 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+    paging.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -146,14 +147,14 @@ vectors.S: vectors.pl
 ULIB = ulib.o usys.o printf.o umalloc.o
 
 _%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
 
 _forktest: forktest.o $(ULIB)
 	# forktest has less library code linked in - needs to be small
 	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o _forktest forktest.o ulib.o usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
@@ -181,6 +182,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+    _dummy\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +219,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -253,6 +255,7 @@ EXTRA=\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
+    dummy.c\
 
 dist:
 	rm -rf dist
diff --git a/defs.h b/defs.h
index 82fb982..927d6b8 100644
--- a/defs.h
+++ b/defs.h
@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 
 // ide.c
 void            ideinit(void);
@@ -120,10 +125,17 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+// [UPOBIR] function to update metadata for aging
+void            updateMetadata();
 
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -175,16 +187,31 @@ void            seginit(void);
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
-int             allocuvm(pde_t*, uint, uint);
+// [UPOBIR]
+int             allocuvm(struct proc* p, pde_t*, uint, uint);
 int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
+// [UPOBIR] copyuvm takes process now
+pde_t*          copyuvm(struct proc* p, struct proc* pp, pde_t* pgdir, uint);
 void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
-void            clearpteu(pde_t *pgdir, char *uva);
+// [UPOBIR] walkpgdir is public now anbd clearpteu takes process
+void            clearpteu(struct proc* p, pde_t *pgdir, char *uva);
+pte_t*          walkpgdir(pde_t *pgdir, const void *va, int alloc);
+
+// [UPOBIR] paging.c function
+// paging.c
+void            addPageRange(struct proc* p, pde_t* pgdir, uint from, uint to);  
+void            removePageRange(struct proc* p, pde_t* pgdir, uint from, uint to);
+void            dumpMetadata(struct proc* p);
+int             pagefault(struct proc* p, uint addr);
+void            updateAgingMetadata(struct proc* p);
+void            clearMetadata(struct proc* p);
+void            addPage(struct proc* p, pde_t* pgdir, int pgnum);
+void            removePage(struct proc* p, pde_t* pgdir, int pgnum);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/dummy.c b/dummy.c
new file mode 100644
index 0000000..ebb191b
--- /dev/null
+++ b/dummy.c
@@ -0,0 +1,77 @@
+// [UPOBIR] dummy program to test paging
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void
+dummy(int proc_count)
+{
+    // declare size and allocate memory
+    int sz = 4096 * 17; 
+    int* mem = (int*)malloc(sz);
+
+    // create children each with different k
+    int k = 13;
+    for(int i = 1; k == 13 && i<proc_count; i++){
+        int pid;
+        if((pid = fork()) == 0)
+            k = 13 + i;
+    }
+
+    // fill memory with multiple of k
+    for(int i = 0; i<sz/4; i++){
+        mem[i] = k * i;  
+    }
+
+    // sleep
+    sleep(250);
+
+    // many pagefaults should have happened by now, check if memory contents are correct
+    int ok = 1;
+    for(int i = 0; i < sz/4; i++){
+        if(mem[i] != k*i)
+            ok = 0;
+    }
+
+    // sleep again
+    sleep(250);
+
+    // print success
+    if(!ok)
+        printf(1, "failed #%d\n", k-13);
+    else
+        printf(1, "success #%d\n", k-13);
+
+    // free memory
+    free((void*)mem);
+
+    // parent should wait for children
+    for(int i = 1; k == 13 && i<proc_count; i++)
+        wait();
+}
+
+
+void nullpoint(){
+    int* x = (int*) 0;
+    printf(1, "null pointer: %d\n", *x);
+}
+
+
+int
+main(int argc, char *argv[])
+{
+    // default process count is 1
+    int proc_count = 1;
+
+    // if arguments are passed, update process count
+    if(argc > 1){
+        proc_count = atoi(argv[1]);
+    }
+
+    // call function
+    dummy(proc_count);
+    //nullpoint();
+
+    exit();
+}
diff --git a/exec.c b/exec.c
index b40134f..ade5b6a 100644
--- a/exec.c
+++ b/exec.c
@@ -38,6 +38,11 @@ exec(char *path, char **argv)
   if((pgdir = setupkvm()) == 0)
     goto bad;
 
+  // [UPOBIR] if not init, remove old pages
+  if(curproc->pid != 1){
+      clearMetadata(curproc);
+  }
+
   // Load program into memory.
   sz = 0;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
@@ -49,7 +54,8 @@ exec(char *path, char **argv)
       goto bad;
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+    //cprintf("exec: %d\n", ph.vaddr);
+    if((sz = allocuvm(curproc, pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
     if(ph.vaddr % PGSIZE != 0)
       goto bad;
@@ -63,9 +69,12 @@ exec(char *path, char **argv)
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  if((sz = allocuvm(curproc, pgdir, sz, sz + 2*PGSIZE)) == 0)
     goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  clearpteu(curproc, pgdir, (char*)(sz - 2*PGSIZE));
+  // [UPOBIR] make 0th page inaccessible to protect null pointer
+  clearpteu(curproc, pgdir, (char*)0);
+
   sp = sz;
 
   // Push argument strings, prepare rest of stack in ustack.
@@ -100,6 +109,10 @@ exec(char *path, char **argv)
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
   switchuvm(curproc);
+  // [UPOBIR] add new process pages
+  //if(curproc->pid != 1){
+  //    //addPageRange(curproc, 0, curproc->sz);
+  //}
   freevm(oldpgdir);
   return 0;
 
diff --git a/fs.c b/fs.c
index f77275f..b2e0375 100644
--- a/fs.c
+++ b/fs.c
@@ -668,3 +668,146 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+    //cprintf("REMOVE %d\n", p->pid);
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+    //cprintf("REMOVING %s\n", path);
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+    //cprintf("CREATED %s\n", path);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/mmu.h b/mmu.h
index a82d8e2..d6b4c8c 100644
--- a/mmu.h
+++ b/mmu.h
@@ -95,6 +95,8 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed
+#define PTE_PG          0x200   // Paged out to secondary storage
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
@@ -178,4 +180,10 @@ struct gatedesc {
   (gate).off_31_16 = (uint)(off) >> 16;                  \
 }
 
+
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+
+#define PTE_PG 0x200 // paged out to secondary storage
+
 #endif
diff --git a/paging.c b/paging.c
new file mode 100644
index 0000000..a7a4272
--- /dev/null
+++ b/paging.c
@@ -0,0 +1,408 @@
+// [UPOBIR] paging functions
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "paging.h"
+#include "proc.h"
+
+void
+clearMetadata(struct proc* p){
+  memset(&p->metadata, -1, sizeof p->metadata); 
+
+#ifdef FIFO_PAGING
+  p->metadata.start = 0;
+#endif
+
+#ifdef AGING_PAGING
+  memset(&p->metadata.aging_bits, 0, sizeof p->metadata.aging_bits); 
+#endif
+
+  return;
+}
+
+
+void
+dumpFifoMetadata(struct fifo_paging_data* data){
+  cprintf("  start: %d\n", data->start);
+  cprintf("  in_phy_queue: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%d ", data->in_phy_queue[i]);
+  }
+  cprintf("\n");
+  cprintf("  in_file_pages: ");
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    cprintf("%d ", data->in_file_pages[i]);
+  }
+  cprintf("\n");
+}
+
+
+void
+dumpAgingMetadata(struct aging_paging_data* data){
+  cprintf("  in_phy: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%d ", data->in_phy[i]);
+  }
+  cprintf("\n");
+  cprintf("  aging_bits: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%p ", data->aging_bits[i]);
+  }
+  cprintf("\n");
+  cprintf("  in_file_pages: ");
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    cprintf("%d ", data->in_file_pages[i]);
+  }
+  cprintf("\n");
+}
+
+void
+dumpMetadata(struct proc* p){
+  if(p->pid == 1)
+    return;
+  cprintf("Metadata:\n");
+
+#ifdef FIFO_PAGING
+  dumpFifoMetadata(&p->metadata);
+#endif
+
+#ifdef AGING_PAGING
+  dumpAgingMetadata(&p->metadata);
+#endif
+}
+
+#ifdef AGING_PAGING
+void updateAgingMetadata(struct proc* p){
+  //cprintf("update: %d\n", p->pid);
+  pte_t* pte;
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    if(p->metadata.in_phy[i] == -1)
+      break;
+    //cprintf("%d\n", p->metadata.in_phy[i]);
+    p->metadata.aging_bits[i] >>= 1;
+    if((pte = walkpgdir(p->pgdir, (void*) (p->metadata.in_phy[i] * PGSIZE), 0)) == 0)
+      panic("updateAgingMetadata: walkpgdir failed");
+    if(*pte & PTE_A){
+      //cprintf("%d accessed %d %d\n", ticks, p->pid, p->metadata.in_phy[i]);
+      p->metadata.aging_bits[i] |= 1<<31;
+    }
+    *pte &= ~PTE_A;
+  }
+}
+#endif
+
+void
+writePageToSwapFile(struct proc* p, pde_t* pgdir, int pgnum, int free_file_loc){
+  pte_t* pte;
+  if((pte = walkpgdir(pgdir, (void*) (pgnum * PGSIZE), 0)) == 0)
+    panic("writePageToSwapFile: walkpgdir failed");
+
+  // write page contents to swap file, in chosen filelocation
+  //cprintf("[WRITE] writing %d to file\n", pgnum) ;
+  uint pa = PTE_ADDR(*pte);
+  writeToSwapFile(p, (char*) P2V(pa) , free_file_loc * PGSIZE, PGSIZE);     
+  kfree((char*) P2V(pa));
+
+  // change flags of written file and write to metadata in_file_pages
+  *pte &= ~PTE_P;
+  *pte |= PTE_PG;
+}
+
+#ifdef FIFO_PAGING
+void 
+addFifoPage(struct proc* p, pde_t* pgdir, int pgnum){
+  // find first free position in metadata in_phy_queue 
+  int free_pos = p->metadata.start;
+  while(1){
+    if(p->metadata.in_phy_queue[free_pos] == -1)
+      break;
+    free_pos++;
+    if(free_pos == MAX_PSYC_PAGES)
+      free_pos = 0;
+    if(free_pos == p->metadata.start)
+      break;
+  }
+
+  // if the position found is not empty (i.e. it is the first position)
+  if(p->metadata.in_phy_queue[free_pos] != -1){
+    if(p->metadata.start != free_pos)
+      panic("addFifoPage: free position doesn't match with queue start");
+
+    // find a free file location in swap file
+    int free_file_loc = 0;
+    for(free_file_loc = 0; free_file_loc<MAX_TOTAL_PAGES; free_file_loc++){
+      if(p->metadata.in_file_pages[free_file_loc] == -1)
+        break;
+    }
+
+    // get pte for that non empty page
+    writePageToSwapFile(p, pgdir, p->metadata.in_phy_queue[free_pos], free_file_loc);
+    p->metadata.in_file_pages[free_file_loc] = p->metadata.in_phy_queue[free_pos];
+
+    // update start of queue
+    p->metadata.start++;
+    if(p->metadata.start == MAX_PSYC_PAGES)
+      p->metadata.start = 0;
+  }
+  
+  // write write new page number to queue
+  p->metadata.in_phy_queue[free_pos] = pgnum;
+}
+#endif
+
+#ifdef AGING_PAGING
+void 
+addAgingPage(struct proc* p, pde_t* pgdir, int pgnum){
+  // find first free position in metadata in_phy_queue 
+  int free_pos;
+  int min_index = 0;
+  for(free_pos = 0; free_pos < MAX_PSYC_PAGES; free_pos++){
+    if(p->metadata.in_phy[free_pos] == -1)
+      break;
+    if(p->metadata.aging_bits[min_index] >= p->metadata.aging_bits[free_pos])
+      min_index = free_pos;
+  }
+
+  if(free_pos == MAX_PSYC_PAGES){
+    free_pos = min_index;
+
+    // find a free file location in swap file
+    int free_file_loc = 0;
+    for(free_file_loc = 0; free_file_loc<MAX_TOTAL_PAGES; free_file_loc++){
+      if(p->metadata.in_file_pages[free_file_loc] == -1)
+        break;
+    }
+
+    // get pte for that non empty page
+    writePageToSwapFile(p, pgdir, p->metadata.in_phy[free_pos], free_file_loc);
+    p->metadata.in_file_pages[free_file_loc] = p->metadata.in_phy[free_pos];
+  }
+
+  // update in phy and aging bits
+  p->metadata.in_phy[free_pos] = pgnum;
+  p->metadata.aging_bits[free_pos] = 1<<31;
+}
+#endif
+
+void 
+addPage(struct proc* p, pde_t* pgdir, int pgnum){
+  //cprintf("adding %s:%d: %d\n", p->name, p->pid, pgnum);
+
+#ifdef FIFO_PAGING
+  addFifoPage(p, pgdir, pgnum);
+#endif
+
+#ifdef AGING_PAGING
+  addAgingPage(p, pgdir, pgnum);
+#endif
+
+  return;
+}
+
+#ifdef FIFO_PAGING
+void
+removeFifoPage(struct proc* p, pde_t* pgdir, int pgnum){
+  // find if it is in queue
+  int pos = p->metadata.start;
+  while(1){
+    if(p->metadata.in_phy_queue[pos] == pgnum)
+      break;
+    pos++;
+    if(pos == MAX_PSYC_PAGES)
+      pos = 0;
+    if(pos == p->metadata.start)
+      break;
+  }
+
+  // if in queue, shift everyone in front to one step back
+  if(p->metadata.in_phy_queue[pos] == pgnum){
+    int prev = pos;
+    p->metadata.in_phy_queue[pos] = -1;
+    pos++;
+    if(pos == MAX_PSYC_PAGES)
+      pos = 0;
+    while(1){
+      if(p->metadata.start == pos || p->metadata.in_phy_queue[pos] == -1)
+        break;
+      p->metadata.in_phy_queue[prev] = p->metadata.in_phy_queue[pos];
+      p->metadata.in_phy_queue[pos] = -1;
+      prev = pos;
+      pos++;
+      if(pos == MAX_PSYC_PAGES)
+        pos = 0;
+    }
+  }
+
+  // look if it is written in file, if it is, remove it
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    if(p->metadata.in_file_pages[i] == pgnum){
+      p->metadata.in_file_pages[i] = -1;
+    }
+  }
+}
+#endif
+
+#ifdef AGING_PAGING
+void
+removeAgingPage(struct proc* p, pde_t* pgdir, int pgnum){
+  // find if it is in physical pages
+  int pos;
+  for(pos = 0; pos < MAX_PSYC_PAGES; pos++){
+    if(p->metadata.in_phy[pos] == pgnum){
+      break;
+    }
+  }
+
+  // if it is in physical page, erase it
+  if(pos != MAX_PSYC_PAGES){
+    p->metadata.in_phy[pos] = -1;
+    p->metadata.aging_bits[pos] = 0;
+  }
+
+  // look if it is written in file, if it is, remove it
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    if(p->metadata.in_file_pages[i] == pgnum){
+      p->metadata.in_file_pages[i] = -1;
+    }
+  }
+}
+#endif
+
+void
+removePage(struct proc* p, pde_t* pgdir, int pgnum){
+  //cprintf("removing %s:%d: %d\n", p->name, p->pid, pgnum);
+
+#ifdef FIFO_PAGING
+  removeFifoPage(p, pgdir, pgnum);
+#endif
+
+#ifdef AGING_PAGING
+  removeAgingPage(p, pgdir, pgnum);
+#endif
+
+  
+}
+
+// half range [from, to)
+void
+addPageRange(struct proc* p, pde_t* pgdir, uint from, uint to){  
+  if (from > to){
+    panic("addPageRange: from > to");
+  }
+
+  //cprintf("adding: from: %d, to: %d\n", from, to);
+
+  for(uint a = PGROUNDUP(from); a < to; a += PGSIZE){
+    int pgnum = a>>12;
+    pte_t* pte;
+    if((pte = walkpgdir(pgdir, (void*) a, 0)) == 0){
+      panic("addPageRange: walkpgdir failed");
+    }
+    if(!(*pte & PTE_U))
+      continue;
+
+    addPage(p, pgdir, pgnum);
+  }
+
+  return;
+}
+
+// half range [from, to)
+void
+removePageRange(struct proc* p, pde_t* pgdir, uint from, uint to){
+  if (from > to){
+    panic("removePageRange: from > to");
+  }
+  
+  //cprintf("removing: from: %d, to: %d\n", from, to);
+
+  for(uint a = PGROUNDUP(from); a < to; a += PGSIZE){
+    int pgnum = a >> 12;
+    pte_t* pte;
+    if((pte = walkpgdir(pgdir, (void*) a, 0)) == 0){
+      panic("removePageRane: walkpgdir failed");
+    }
+
+    if(!(*pte & PTE_U))
+      continue;
+      
+    removePage(p, pgdir, pgnum);
+  }
+
+}
+
+
+/*
+fork
+    allocproc
+        allocuvm
+growproc
+    allocuvm
+    deallocuvm
+exec
+
+
+proc.c
+exec.c
+*/
+
+// handle page fault and tell if it's a user page
+int pagefault_count = 0;
+
+int
+pagefault(struct proc* p, uint addr){
+  pagefault_count ++;
+
+  int pgnum = addr >> 12; 
+  //cprintf("\npagefault: %d\n", pgnum);
+
+  // check if actual pagefault
+
+  //cprintf("\n\n\n%d\n", pgnum);
+  //dumpMetadata(p);
+  pte_t* pte;
+  if((pte = walkpgdir(p->pgdir, (void*) (pgnum * PGSIZE), 0)) == 0){
+      dumpMetadata(p);
+    return -1;
+  }
+
+  //cprintf("checking: %p\n", *pte);
+  if(*pte & PTE_P){
+      dumpMetadata(p);
+    return -1;
+  }
+
+  if(!(*pte & PTE_PG)){
+      dumpMetadata(p);
+    return -1;
+  }
+
+  int file_location;
+  for(file_location = 0; file_location<MAX_TOTAL_PAGES; file_location++){
+    if(p->metadata.in_file_pages[file_location] == pgnum)
+      break;
+  }
+
+  if(file_location == MAX_TOTAL_PAGES)
+    panic("pagefault: could not find page among paged out pages");
+
+  *pte &= ((1<<PTXSHIFT)-1);
+  char* mem = kalloc();
+  *pte |= (pte_t) V2P(mem);
+
+  uint pa = PTE_ADDR(*pte);
+  //cprintf("[READ] reading page %d\n", pgnum);
+  readFromSwapFile(p, (char*) P2V(pa), file_location * PGSIZE, PGSIZE);
+  p->metadata.in_file_pages[file_location] = -1;
+   
+  *pte |= PTE_P;
+  *pte &= ~PTE_PG;
+
+  addPage(p, p->pgdir, pgnum);
+  //dumpMetadata(p);
+  return 0;
+}
diff --git a/paging.h b/paging.h
new file mode 100644
index 0000000..aad2deb
--- /dev/null
+++ b/paging.h
@@ -0,0 +1,24 @@
+// [UPOBIR] paging structures
+
+#ifndef PAGING_H
+#define PAGING_H
+
+#define FIFO_PAGING
+
+struct fifo_paging_data {
+    int in_phy_queue[MAX_PSYC_PAGES];
+    int in_file_pages[MAX_TOTAL_PAGES];
+    int start;
+};
+
+struct aging_paging_data {
+    int in_phy[MAX_PSYC_PAGES];
+    uint aging_bits[MAX_PSYC_PAGES];
+    int in_file_pages[MAX_TOTAL_PAGES];
+};
+
+// TODO not allocate page 0 or just clear PTE_U
+// TODO manually set/unset PTE_A
+// TODO forktest won't work now, why did you plagiarize the spec?
+
+#endif // PAGING_H 
diff --git a/proc.c b/proc.c
index 806b1b1..c6b1854 100644
--- a/proc.c
+++ b/proc.c
@@ -102,6 +102,9 @@ found:
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
 
+  // [UPOBIR] clear metadata of allocated process
+  clearMetadata(p);
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -158,19 +161,27 @@ userinit(void)
 int
 growproc(int n)
 {
+  //cprintf("grow: %d %s:%d\n", n, myproc()->name, myproc()->pid);
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
+  //cprintf("growproc: %d\n", sz % 4096 == 0);
   if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+    if((sz = allocuvm(curproc, curproc->pgdir, sz, sz + n)) == 0)
       return -1;
+    // [UPOBIR] add page range when growing memory
+    //addPageRange(curproc, curproc->sz, sz);
   } else if(n < 0){
     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
+    // [UPOBIR] remove page range when shrinking memory
+    removePageRange(curproc, curproc->pgdir, sz, curproc->sz);
   }
   curproc->sz = sz;
+  //cprintf("growproc: %d\n", sz % 4096 == 0);
   switchuvm(curproc);
+  //cprintf("%s:%d current size = %d\n", curproc->name, curproc->pid, curproc->sz);
   return 0;
 }
 
@@ -190,10 +201,15 @@ fork(void)
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  // [UPOBIR] creating swap file and adding pages to metadata
+  createSwapFile(np);
+  //addPageRange(np, 0, np->sz);
+
+  if((np->pgdir = copyuvm(np, curproc, curproc->pgdir, curproc->sz)) == 0){
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
+    removeSwapFile(np);
     return -1;
   }
   np->sz = curproc->sz;
@@ -210,6 +226,7 @@ fork(void)
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
+
   pid = np->pid;
 
   acquire(&ptable.lock);
@@ -265,6 +282,7 @@ exit(void)
   curproc->state = ZOMBIE;
   sched();
   panic("zombie exit");
+  removeSwapFile(curproc);
 }
 
 // Wait for a child process to exit and return its pid.
@@ -285,6 +303,8 @@ wait(void)
         continue;
       havekids = 1;
       if(p->state == ZOMBIE){
+        // [UPOBIR] create temporary process to remove it's swap file later
+        struct proc tmp = *p;
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -296,6 +316,9 @@ wait(void)
         p->killed = 0;
         p->state = UNUSED;
         release(&ptable.lock);
+        // [UPOBIR] remove swap file of terminated process
+        removeSwapFile(&tmp);
+        
         return pid;
       }
     }
@@ -500,6 +523,26 @@ kill(int pid)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
+
+
+// [UPOBIR] update meta data function
+void
+updateMetadata(){
+  acquire(&ptable.lock);
+  for(struct proc* p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED || p->pid == 1)
+      continue;
+#ifdef AGING_PAGING
+    if(p->state == RUNNING)
+      updateAgingMetadata(p);
+#endif
+  }
+  release(&ptable.lock);
+}
+
+
+extern int pagefault_count;
+
 void
 procdump(void)
 {
@@ -530,5 +573,50 @@ procdump(void)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
+
+    //cprintf("expected page count: %d / 4096 = %d\n", p->sz, p->sz / 4096);
+
+    // [UPOBIR] adding page table prints
+    int v_pages[MAX_TOTAL_PAGES];
+    int p_pages[MAX_TOTAL_PAGES];
+    int pagecnt = 0;
+
+    // TODO pointers or ints?
+    cprintf("Page tables:\n");
+    cprintf("  memory location of page directory = %p\n", V2P(p->pgdir));
+    /*if(tmp[0] != tmp2[0])
+        panic("oh no 69");*/
+    // TODO NPDENTRIES or 512?
+    for(int i = 0; i<(KERNBASE>>22); i++){
+      pde_t pde = p->pgdir[i];
+      if(!(pde & PTE_U))
+        continue;
+
+      cprintf("  pdir PTE %d, %d:\n", i, pde >> 12  );
+      cprintf("    memory location of page table = %p\n", PTE_ADDR(pde));
+
+      pte_t* table = (pte_t*) P2V(PTE_ADDR(pde));
+
+      for(int j = 0; j<NPTENTRIES; j++){
+          pte_t pte = table[j];
+          if(!(pte & PTE_U))
+              continue;
+
+          cprintf("    ptbl PTE %d, %d, %p\n", j, pte >> 12, PTE_ADDR(pte));
+          v_pages[pagecnt] = (i << 10) | j; 
+          p_pages[pagecnt] = pte >> 12;
+          if(!(pte & PTE_P))
+            p_pages[pagecnt] = -1;
+          pagecnt++;
+      }
+    }
+
+    cprintf("Page mappings:\n");
+    for(int i = 0; i<pagecnt; i++){
+      cprintf("%d -> %d\n", v_pages[i], p_pages[i]);
+    }
+    dumpMetadata(p);
   }
+
+  cprintf("\npage fault count: %d\n", pagefault_count);
 }
diff --git a/proc.h b/proc.h
index 1647114..aa55d56 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,6 @@
+//UPOBIR including paging.h
+#include "paging.h"
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -49,6 +52,15 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+  // [UPOBIR] metadata in proc structure
+#ifdef FIFO_PAGING
+  struct fifo_paging_data metadata;
+#endif
+#ifdef AGING_PAGING
+  struct aging_paging_data metadata;
+#endif
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/sh.c b/sh.c
index 054bab9..1882abe 100644
--- a/sh.c
+++ b/sh.c
@@ -361,6 +361,7 @@ parseline(char **ps, char *es)
 struct cmd*
 parsepipe(char **ps, char *es)
 {
+  
   struct cmd *cmd;
 
   cmd = parseexec(ps, es);
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..bf3848e 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
diff --git a/trap.c b/trap.c
index 41c66eb..ace62ef 100644
--- a/trap.c
+++ b/trap.c
@@ -53,6 +53,7 @@ trap(struct trapframe *tf)
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
+      updateMetadata();
     }
     lapiceoi();
     break;
@@ -78,7 +79,16 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
 
-  //PAGEBREAK: 13
+  // [UPOBIR] handling pagefault
+  case T_PGFLT:{
+      uint addr = rcr2();
+      if(pagefault(myproc(), addr) < 0){
+        cprintf("Segmentation fault\n");
+        myproc()->killed = 1; 
+      }
+      lapiceoi();
+    } break; 
+  
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
diff --git a/types.h b/types.h
index e4adf64..b30d57c 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,4 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+typedef uint pte_t;
diff --git a/umalloc.c b/umalloc.c
index a7e7d2c..077bbe9 100644
--- a/umalloc.c
+++ b/umalloc.c
@@ -67,6 +67,7 @@ malloc(uint nbytes)
   uint nunits;
 
   nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  //printf(1, "malloc: %d\n", nunits);
   if((prevp = freep) == 0){
     base.s.ptr = freep = prevp = &base;
     base.s.size = 0;
diff --git a/vm.c b/vm.c
index 7134cff..f7eea9d 100644
--- a/vm.c
+++ b/vm.c
@@ -32,7 +32,7 @@ seginit(void)
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
-static pte_t *
+pte_t *
 walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
   pde_t *pde;
@@ -46,6 +46,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
+    //cprintf("allocating page table entry for %p\n", pgdir );
     // The permissions here are overly generous, but they can
     // be further restricted by the permissions in the page table
     // entries, if necessary.
@@ -219,7 +220,7 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+allocuvm(struct proc* p, pde_t* pgdir, uint oldsz, uint newsz)
 {
   char *mem;
   uint a;
@@ -244,6 +245,8 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       kfree(mem);
       return 0;
     }
+    if(p->pid != 1)
+      addPage(p, pgdir, a/PGSIZE);
   }
   return newsz;
 }
@@ -300,7 +303,7 @@ freevm(pde_t *pgdir)
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
 void
-clearpteu(pde_t *pgdir, char *uva)
+clearpteu(struct proc* p, pde_t *pgdir, char *uva)
 {
   pte_t *pte;
 
@@ -308,12 +311,18 @@ clearpteu(pde_t *pgdir, char *uva)
   if(pte == 0)
     panic("clearpteu");
   *pte &= ~PTE_U;
+
+  if(!(*pte & PTE_P)){
+    cprintf("doing\n");
+    pagefault(p, (uint) uva);
+  }
+  removePage(p, pgdir, ((uint) uva) / PGSIZE);
 }
 
 // Given a parent process's page table, create a copy
 // of it for a child.
 pde_t*
-copyuvm(pde_t *pgdir, uint sz)
+copyuvm(struct proc* p, struct proc* pp, pde_t* pgdir, uint sz)
 {
   pde_t *d;
   pte_t *pte;
@@ -325,8 +334,16 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
+    if(!(*pte & PTE_P)){
+      // [UPOBIR] when copying parent memory, page in memoery if not present
+      //panic("copyuvm: page not present");
+      if(pagefault(pp, i) == -1){
+        panic("copyuvm: page fault failed");
+      }
+
+      if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+        panic("copyuvm: pagetable should exist");
+    }
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -336,6 +353,9 @@ copyuvm(pde_t *pgdir, uint sz)
       kfree(mem);
       goto bad;
     }
+
+    if(*pte & PTE_U)
+      addPage(p, d, i/PGSIZE);
   }
   return d;
 
