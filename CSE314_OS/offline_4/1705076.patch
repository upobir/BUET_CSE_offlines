diff --git a/Makefile b/Makefile
index 09d790c..91052b0 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,7 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+    paging.o\
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -146,14 +147,14 @@ vectors.S: vectors.pl
 ULIB = ulib.o usys.o printf.o umalloc.o
 
 _%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o $@ $^
 	$(OBJDUMP) -S $@ > $*.asm
 	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
 
 _forktest: forktest.o $(ULIB)
 	# forktest has less library code linked in - needs to be small
 	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0x1000 -o _forktest forktest.o ulib.o usys.o
 	$(OBJDUMP) -S _forktest > forktest.asm
 
 mkfs: mkfs.c fs.h
@@ -181,6 +182,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+    _dummy\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +219,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -253,6 +255,7 @@ EXTRA=\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
+    dummy.c\
 
 dist:
 	rm -rf dist
diff --git a/defs.h b/defs.h
index 82fb982..0d80707 100644
--- a/defs.h
+++ b/defs.h
@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 
 // ide.c
 void            ideinit(void);
@@ -120,10 +125,17 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+// [UPOBIR]
+void            updateMetadata();
 
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -180,11 +192,20 @@ int             deallocuvm(pde_t*, uint, uint);
 void            freevm(pde_t*);
 void            inituvm(pde_t*, char*, uint);
 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
+pde_t*          copyuvm(struct proc* p, uint);
 void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+pte_t*          walkpgdir(pde_t *pgdir, const void *va, int alloc);
+
+// [UPOBIR]
+// paging.c
+void            addPageRange(struct proc* p, uint from, uint to);  
+void            removePageRange(struct proc* p, uint from, uint to);
+void            dumpMetadata(struct proc* p);
+int             pagefault(struct proc* p, uint addr);
+void            updateAgingMetadata(struct proc* p);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/dummy.c b/dummy.c
new file mode 100644
index 0000000..a0ed705
--- /dev/null
+++ b/dummy.c
@@ -0,0 +1,66 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void
+dummy()
+{
+    int sz = 4096 * 17; 
+    int* mem = (int*)malloc(sz);
+
+    int pid = fork();
+    int k;
+    if(pid == 0){
+      k = 17;
+    }
+    else{
+      k = 13;
+    }
+
+    //int x = *(int*)(4096 * 124);
+    //printf(1, "%d\n", x);
+    
+    for(int i = 0; i<sz/4; i++){
+        mem[i] = k * i;  
+    }
+
+    sleep(250);
+
+    int ok = 1;
+    for(int i = 0; i<sz/4; i++){
+        if(mem[i] != k*i)
+            ok = 0;
+    }
+
+    sleep(250);
+
+    if(!ok)
+        printf(2, "failed\n");
+    else
+        printf(2, "success\n");
+
+    free((void*)mem);
+
+    if(pid != 0)
+      wait();
+}
+
+void rec(int x, int y){
+    printf(2, "hello\n");
+    rec(x+1, y+1);
+    printf(2, "bye\n");
+}
+
+void nullpoint(){
+    int* x = (int*) 0;
+    printf(1, "null pointer: %d\n", *x);
+}
+
+int
+main(int argc, char *argv[])
+{
+    dummy();
+    //rec(0, 0);
+    //nullpoint();
+    exit();
+}
diff --git a/exec.c b/exec.c
index b40134f..d2e9043 100644
--- a/exec.c
+++ b/exec.c
@@ -49,6 +49,7 @@ exec(char *path, char **argv)
       goto bad;
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
+    //cprintf("exec: %d\n", ph.vaddr);
     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
     if(ph.vaddr % PGSIZE != 0)
@@ -66,6 +67,8 @@ exec(char *path, char **argv)
   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
     goto bad;
   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  // [UPOBIR]
+  clearpteu(pgdir, (char*)0);
   sp = sz;
 
   // Push argument strings, prepare rest of stack in ustack.
@@ -95,11 +98,21 @@ exec(char *path, char **argv)
 
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
+  // [UPOBIR]
+  if(curproc->pid != 1){
+      //cprintf("exec: %d\n", curproc->pid);
+      removePageRange(curproc, 0, curproc->sz);
+  }
   curproc->pgdir = pgdir;
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
   switchuvm(curproc);
+  // [UPOBIR]
+  if(curproc->pid != 1){
+      //cprintf("exec: %d\n", curproc->pid);
+      addPageRange(curproc, 0, curproc->sz);
+  }
   freevm(oldpgdir);
   return 0;
 
diff --git a/fs.c b/fs.c
index f77275f..b2e0375 100644
--- a/fs.c
+++ b/fs.c
@@ -668,3 +668,146 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+    //cprintf("REMOVE %d\n", p->pid);
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+    //cprintf("REMOVING %s\n", path);
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+    //cprintf("CREATED %s\n", path);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/mmu.h b/mmu.h
index a82d8e2..d6b4c8c 100644
--- a/mmu.h
+++ b/mmu.h
@@ -95,6 +95,8 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed
+#define PTE_PG          0x200   // Paged out to secondary storage
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
@@ -178,4 +180,10 @@ struct gatedesc {
   (gate).off_31_16 = (uint)(off) >> 16;                  \
 }
 
+
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+
+#define PTE_PG 0x200 // paged out to secondary storage
+
 #endif
diff --git a/paging.c b/paging.c
new file mode 100644
index 0000000..fc5b835
--- /dev/null
+++ b/paging.c
@@ -0,0 +1,384 @@
+// [UPOBIR]
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "paging.h"
+#include "proc.h"
+
+void
+dumpFifoMetadata(struct fifo_paging_data* data){
+  cprintf("  start: %d\n", data->start);
+  cprintf("  in_phy_queue: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%d ", data->in_phy_queue[i]);
+  }
+  cprintf("\n");
+  cprintf("  in_file_pages: ");
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    cprintf("%d ", data->in_file_pages[i]);
+  }
+  cprintf("\n");
+}
+
+void
+dumpAgingMetadata(struct aging_paging_data* data){
+  cprintf("  in_phy: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%d ", data->in_phy[i]);
+  }
+  cprintf("\n");
+  cprintf("  aging_bits: ");
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    cprintf("%p ", data->aging_bits[i]);
+  }
+  cprintf("\n");
+  cprintf("  in_file_pages: ");
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    cprintf("%d ", data->in_file_pages[i]);
+  }
+  cprintf("\n");
+}
+
+void
+dumpMetadata(struct proc* p){
+  if(p->pid == 1)
+    return;
+  cprintf("Metadata:\n");
+
+#ifdef FIFO_PAGING
+  dumpFifoMetadata(&p->metadata);
+#endif
+
+#ifdef AGING_PAGING
+  dumpAgingMetadata(&p->metadata);
+#endif
+}
+
+#ifdef AGING_PAGING
+void updateAgingMetadata(struct proc* p){
+  //cprintf("update: %d\n", p->pid);
+  pte_t* pte;
+  for(int i = 0; i<MAX_PSYC_PAGES; i++){
+    if(p->metadata.in_phy[i] == -1)
+      break;
+    //cprintf("%d\n", p->metadata.in_phy[i]);
+    p->metadata.aging_bits[i] >>= 1;
+    if((pte = walkpgdir(p->pgdir, (void*) (p->metadata.in_phy[i] * PGSIZE), 0)) == 0)
+      panic("oh no 7");
+    if(*pte & PTE_A){
+      //cprintf("%d accessed %d %d\n", ticks, p->pid, p->metadata.in_phy[i]);
+      p->metadata.aging_bits[i] |= 1<<31;
+    }
+    *pte &= ~PTE_A;
+  }
+}
+#endif
+
+void
+writePageToSwapFile(struct proc* p, int pgnum, int free_file_loc){
+  pte_t* pte;
+  if((pte = walkpgdir(p->pgdir, (void*) (pgnum * PGSIZE), 0)) == 0)
+    panic("oh no 2");
+
+  // write page contents to swap file, in chosen filelocation
+  //cprintf("writing %d to file\n", pgnum) ;
+  uint pa = PTE_ADDR(*pte);
+  writeToSwapFile(p, (char*) P2V(pa) , free_file_loc * PGSIZE, PGSIZE);     
+  kfree((char*) P2V(pa));
+
+  // change flags of written file and write to metadata in_file_pages
+  *pte &= ~PTE_P;
+  *pte |= PTE_PG;
+}
+
+#ifdef FIFO_PAGING
+void 
+addFifoPage(struct proc* p, int pgnum){
+  // find first free position in metadata in_phy_queue 
+  int free_pos = p->metadata.start;
+  while(1){
+    if(p->metadata.in_phy_queue[free_pos] == -1)
+      break;
+    free_pos++;
+    if(free_pos == MAX_PSYC_PAGES)
+      free_pos = 0;
+    if(free_pos == p->metadata.start)
+      break;
+  }
+
+  // if the position found is not empty (i.e. it is the first position)
+  if(p->metadata.in_phy_queue[free_pos] != -1){
+    if(p->metadata.start != free_pos)
+      panic("oh no");
+
+    // find a free file location in swap file
+    int free_file_loc = 0;
+    for(free_file_loc = 0; free_file_loc<MAX_TOTAL_PAGES; free_file_loc++){
+      if(p->metadata.in_file_pages[free_file_loc] == -1)
+        break;
+    }
+
+    // get pte for that non empty page
+    writePageToSwapFile(p, p->metadata.in_phy_queue[free_pos], free_file_loc);
+    p->metadata.in_file_pages[free_file_loc] = p->metadata.in_phy_queue[free_pos];
+
+    // update start of queue
+    p->metadata.start++;
+    if(p->metadata.start == MAX_PSYC_PAGES)
+      p->metadata.start = 0;
+  }
+  
+  // write write new page number to queue
+  p->metadata.in_phy_queue[free_pos] = pgnum;
+}
+#endif
+
+#ifdef AGING_PAGING
+void 
+addAgingPage(struct proc* p, int pgnum){
+  // find first free position in metadata in_phy_queue 
+  int free_pos;
+  int min_index = 0;
+  for(free_pos = 0; free_pos < MAX_PSYC_PAGES; free_pos++){
+    if(p->metadata.in_phy[free_pos] == -1)
+      break;
+    if(p->metadata.aging_bits[min_index] >= p->metadata.aging_bits[free_pos])
+      min_index = free_pos;
+  }
+
+  if(free_pos == MAX_PSYC_PAGES){
+    free_pos = min_index;
+
+    // find a free file location in swap file
+    int free_file_loc = 0;
+    for(free_file_loc = 0; free_file_loc<MAX_TOTAL_PAGES; free_file_loc++){
+      if(p->metadata.in_file_pages[free_file_loc] == -1)
+        break;
+    }
+
+    // get pte for that non empty page
+    writePageToSwapFile(p, p->metadata.in_phy[free_pos], free_file_loc);
+    p->metadata.in_file_pages[free_file_loc] = p->metadata.in_phy[free_pos];
+  }
+
+  // update in phy and aging bits
+  p->metadata.in_phy[free_pos] = pgnum;
+  p->metadata.aging_bits[free_pos] = 1<<31;
+}
+#endif
+
+void 
+addPage(struct proc* p, int pgnum){
+  //cprintf("adding %s:%d: %d\n", p->name, p->pid, pgnum);
+
+#ifdef FIFO_PAGING
+  addFifoPage(p, pgnum);
+#endif
+
+#ifdef AGING_PAGING
+  addAgingPage(p, pgnum);
+#endif
+
+  return;
+}
+
+#ifdef FIFO_PAGING
+void
+removeFifoPage(struct proc* p, int pgnum){
+  // find if it is in queue
+  int pos = p->metadata.start;
+  while(1){
+    if(p->metadata.in_phy_queue[pos] == pgnum)
+      break;
+    pos++;
+    if(pos == MAX_PSYC_PAGES)
+      pos = 0;
+    if(pos == p->metadata.start)
+      break;
+  }
+
+  // if in queue, shift everyone in front to one step back
+  if(p->metadata.in_phy_queue[pos] == pgnum){
+    int prev = pos;
+    p->metadata.in_phy_queue[pos] = -1;
+    pos++;
+    if(pos == MAX_PSYC_PAGES)
+      pos = 0;
+    while(1){
+      if(p->metadata.start == pos || p->metadata.in_phy_queue[pos] == -1)
+        break;
+      p->metadata.in_phy_queue[prev] = p->metadata.in_phy_queue[pos];
+      p->metadata.in_phy_queue[pos] = -1;
+      prev = pos;
+      pos++;
+      if(pos == MAX_PSYC_PAGES)
+        pos = 0;
+    }
+  }
+
+  // look if it is written in file, if it is, remove it
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    if(p->metadata.in_file_pages[i] == pgnum){
+      p->metadata.in_file_pages[i] = -1;
+    }
+  }
+}
+#endif
+
+#ifdef AGING_PAGING
+void
+removeAgingPage(struct proc* p, int pgnum){
+  // find if it is in physical pages
+  int pos;
+  for(pos = 0; pos < MAX_PSYC_PAGES; pos++){
+    if(p->metadata.in_phy[pos] == pgnum){
+      break;
+    }
+  }
+
+  // if it is in physical page, erase it
+  if(pos != MAX_PSYC_PAGES){
+    p->metadata.in_phy[pos] = -1;
+    p->metadata.aging_bits[pos] = 0;
+  }
+
+  // look if it is written in file, if it is, remove it
+  for(int i = 0; i<MAX_TOTAL_PAGES; i++){
+    if(p->metadata.in_file_pages[i] == pgnum){
+      p->metadata.in_file_pages[i] = -1;
+    }
+  }
+}
+#endif
+
+void
+removePage(struct proc* p, int pgnum){
+  //cprintf("removing %s:%d: %d\n", p->name, p->pid, pgnum);
+
+#ifdef FIFO_PAGING
+  removeFifoPage(p, pgnum);
+#endif
+
+#ifdef AGING_PAGING
+  removeAgingPage(p, pgnum);
+#endif
+
+  
+}
+
+// half range [from, to)
+void
+addPageRange(struct proc* p, uint from, uint to){  
+  if (from > to){
+    panic("from > to");
+  }
+
+  //cprintf("adding: from: %d, to: %d\n", from, to);
+
+  for(uint a = PGROUNDUP(from); a < to; a += PGSIZE){
+    int pgnum = a>>12;
+    pte_t* pte;
+    if((pte = walkpgdir(p->pgdir, (void*) a, 0)) == 0){
+      panic("oh no 3");
+    }
+    if(!(*pte & PTE_U))
+      continue;
+
+    addPage(p, pgnum);
+  }
+
+  return;
+}
+
+// half range [from, to)
+void
+removePageRange(struct proc* p, uint from, uint to){
+  if (from > to){
+    panic("from > to");
+  }
+  
+  //cprintf("removing: from: %d, to: %d\n", from, to);
+
+  for(uint a = PGROUNDUP(from); a < to; a += PGSIZE){
+    int pgnum = a >> 12;
+    pte_t* pte;
+    if((pte = walkpgdir(p->pgdir, (void*) a, 0)) == 0){
+      panic("oh no 4");
+    }
+
+    if(!(*pte & PTE_U))
+      continue;
+      
+    removePage(p, pgnum);
+  }
+
+}
+
+
+/*
+fork
+    allocproc
+        allocuvm
+growproc
+    allocuvm
+    deallocuvm
+exec
+
+
+proc.c
+exec.c
+*/
+
+// handle page fault and tell if it's a user page
+int
+pagefault(struct proc* p, uint addr){
+  int pgnum = addr >> 12; 
+  //cprintf("\npagefault: %d\n", pgnum);
+
+  // check if actual pagefault
+
+  //cprintf("\n\n\n%d\n", pgnum);
+  //dumpMetadata(p);
+  pte_t* pte;
+  if((pte = walkpgdir(p->pgdir, (void*) (pgnum * PGSIZE), 0)) == 0)
+    return -1;
+
+  //cprintf("checking: %p\n", *pte);
+  if(*pte & PTE_P)
+    return -1;
+
+  if(!(*pte & PTE_PG))
+    return -1;
+
+  int file_location;
+  for(file_location = 0; file_location<MAX_TOTAL_PAGES; file_location++){
+    if(p->metadata.in_file_pages[file_location] == pgnum)
+      break;
+  }
+
+  if(file_location == MAX_TOTAL_PAGES)
+    panic("oh no 6");
+
+  *pte &= ((1<<PTXSHIFT)-1);
+  char* mem = kalloc();
+  //if((mem & ~((1<<PTXSHIFT)-1)) != 0)
+  //  panic("oh no 7");
+  *pte |= (pte_t) V2P(mem);
+
+  uint pa = PTE_ADDR(*pte);
+  readFromSwapFile(p, (char*) P2V(pa), file_location * PGSIZE, PGSIZE);
+  p->metadata.in_file_pages[file_location] = -1;
+   
+  *pte |= PTE_P;
+  *pte &= ~PTE_PG;
+
+  addPage(p, pgnum);
+  //dumpMetadata(p);
+  return 0;
+}
+
+
diff --git a/paging.h b/paging.h
new file mode 100644
index 0000000..21fc4e1
--- /dev/null
+++ b/paging.h
@@ -0,0 +1,24 @@
+// [UPOBIR]
+
+#ifndef PAGING_H
+#define PAGING_H
+
+#define AGING_PAGING
+
+struct fifo_paging_data {
+    int in_phy_queue[MAX_PSYC_PAGES];
+    int in_file_pages[MAX_TOTAL_PAGES];
+    int start;
+};
+
+struct aging_paging_data {
+    int in_phy[MAX_PSYC_PAGES];
+    uint aging_bits[MAX_PSYC_PAGES];
+    int in_file_pages[MAX_TOTAL_PAGES];
+};
+
+// TODO not allocate page 0 or just clear PTE_U
+// TODO manually set/unset PTE_A
+// TODO forktest won't work now, why did you plagiarize the spec?
+
+#endif // PAGING_H 
diff --git a/proc.c b/proc.c
index 806b1b1..9bf34bd 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,8 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+// [UPOBIR]
+#include "paging.h"
 
 struct {
   struct spinlock lock;
@@ -102,6 +104,9 @@ found:
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
 
+  // [UPOBIR]
+  memset(&p->metadata, -1, sizeof p->metadata);
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -158,19 +163,27 @@ userinit(void)
 int
 growproc(int n)
 {
+  //cprintf("grow: %d %s:%d\n", n, myproc()->name, myproc()->pid);
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
+  //cprintf("growproc: %d\n", sz % 4096 == 0);
   if(n > 0){
     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
+    // [UPOBIR]
+    addPageRange(curproc, curproc->sz, sz);
   } else if(n < 0){
     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
+    // [UPOBIR]
+    //removePageRange(curproc, sz, curproc->sz);
   }
   curproc->sz = sz;
+  //cprintf("growproc: %d\n", sz % 4096 == 0);
   switchuvm(curproc);
+  //cprintf("%s:%d current size = %d\n", curproc->name, curproc->pid, curproc->sz);
   return 0;
 }
 
@@ -190,7 +203,7 @@ fork(void)
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if((np->pgdir = copyuvm(curproc, curproc->sz)) == 0){
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -210,6 +223,17 @@ fork(void)
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
+  // [UPOBIR]  
+  createSwapFile(np);
+  memset(&np->metadata, -1, sizeof np->metadata); 
+#ifdef FIFO_PAGING
+  np->metadata.start = 0;
+#endif
+#ifdef AGING_PAGING
+  memset(&np->metadata.aging_bits, 0, sizeof np->metadata.aging_bits); 
+#endif
+  addPageRange(np, 0, np->sz);
+
   pid = np->pid;
 
   acquire(&ptable.lock);
@@ -285,6 +309,8 @@ wait(void)
         continue;
       havekids = 1;
       if(p->state == ZOMBIE){
+        // [UPOBIR]
+        struct proc tmp = *p;
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -296,6 +322,9 @@ wait(void)
         p->killed = 0;
         p->state = UNUSED;
         release(&ptable.lock);
+        // [UPOBIR]
+        removeSwapFile(&tmp);
+        
         return pid;
       }
     }
@@ -500,6 +529,23 @@ kill(int pid)
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
+
+
+void
+updateMetadata(){
+  acquire(&ptable.lock);
+  for(struct proc* p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED || p->pid == 1)
+      continue;
+#ifdef AGING_PAGING
+    if(p->state == RUNNING)
+      updateAgingMetadata(p);
+#endif
+  }
+  release(&ptable.lock);
+}
+
+
 void
 procdump(void)
 {
@@ -530,5 +576,48 @@ procdump(void)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
+
+    //cprintf("expected page count: %d / 4096 = %d\n", p->sz, p->sz / 4096);
+
+    // [UPOBIR] adding page table prints
+    int v_pages[MAX_TOTAL_PAGES];
+    int p_pages[MAX_TOTAL_PAGES];
+    int pagecnt = 0;
+
+    // TODO pointers or ints?
+    cprintf("Page tables:\n");
+    cprintf("  memory location of page directory = %p\n", V2P(p->pgdir));
+    /*if(tmp[0] != tmp2[0])
+        panic("oh no 69");*/
+    // TODO NPDENTRIES or 512?
+    for(int i = 0; i<(KERNBASE>>22); i++){
+      pde_t pde = p->pgdir[i];
+      if(!(pde & PTE_U))
+        continue;
+
+      cprintf("  pdir PTE %d, %d:\n", i, pde >> 12  );
+      cprintf("    memory location of page table = %p\n", PTE_ADDR(pde));
+
+      pte_t* table = (pte_t*) P2V(PTE_ADDR(pde));
+
+      for(int j = 0; j<NPTENTRIES; j++){
+          pte_t pte = table[j];
+          if(!(pte & PTE_U))
+              continue;
+
+          cprintf("    ptbl PTE %d, %d, %p\n", j, pte >> 12, PTE_ADDR(pte));
+          v_pages[pagecnt] = (i << 10) | j; 
+          p_pages[pagecnt] = pte >> 12;
+          if(!(pte & PTE_P))
+            p_pages[pagecnt] = -1;
+          pagecnt++;
+      }
+    }
+
+    cprintf("Page mappings:\n");
+    for(int i = 0; i<pagecnt; i++){
+      cprintf("%d -> %d\n", v_pages[i], p_pages[i]);
+    }
+    dumpMetadata(p);
   }
 }
diff --git a/proc.h b/proc.h
index 1647114..dcdbf3c 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,6 @@
+//UPOBIR
+#include "paging.h"
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -49,6 +52,14 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+#ifdef FIFO_PAGING
+  struct fifo_paging_data metadata;
+#endif
+#ifdef AGING_PAGING
+  struct aging_paging_data metadata;
+#endif
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/sh.c b/sh.c
index 054bab9..1882abe 100644
--- a/sh.c
+++ b/sh.c
@@ -361,6 +361,7 @@ parseline(char **ps, char *es)
 struct cmd*
 parsepipe(char **ps, char *es)
 {
+  
   struct cmd *cmd;
 
   cmd = parseexec(ps, es);
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..bf3848e 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
diff --git a/trap.c b/trap.c
index 41c66eb..f98bdc7 100644
--- a/trap.c
+++ b/trap.c
@@ -53,6 +53,7 @@ trap(struct trapframe *tf)
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
+      updateMetadata();
     }
     lapiceoi();
     break;
@@ -78,7 +79,16 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
 
-  //PAGEBREAK: 13
+  // [UPOBIR]
+  case T_PGFLT:{
+      uint addr = rcr2();
+      if(pagefault(myproc(), addr) < 0){
+        cprintf("Segmentation fault\n");
+        myproc()->killed = 1; 
+      }
+      lapiceoi();
+    } break; 
+  
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
diff --git a/types.h b/types.h
index e4adf64..b30d57c 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,4 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+typedef uint pte_t;
diff --git a/umalloc.c b/umalloc.c
index a7e7d2c..077bbe9 100644
--- a/umalloc.c
+++ b/umalloc.c
@@ -67,6 +67,7 @@ malloc(uint nbytes)
   uint nunits;
 
   nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  //printf(1, "malloc: %d\n", nunits);
   if((prevp = freep) == 0){
     base.s.ptr = freep = prevp = &base;
     base.s.size = 0;
diff --git a/vm.c b/vm.c
index 7134cff..ed8a6c1 100644
--- a/vm.c
+++ b/vm.c
@@ -32,7 +32,7 @@ seginit(void)
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
-static pte_t *
+pte_t *
 walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
   pde_t *pde;
@@ -46,6 +46,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
+    //cprintf("allocating page table entry for %p\n", pgdir );
     // The permissions here are overly generous, but they can
     // be further restricted by the permissions in the page table
     // entries, if necessary.
@@ -313,8 +314,11 @@ clearpteu(pde_t *pgdir, char *uva)
 // Given a parent process's page table, create a copy
 // of it for a child.
 pde_t*
-copyuvm(pde_t *pgdir, uint sz)
+copyuvm(struct proc* p, uint sz)
 {
+  // [UPOBIR]
+  pde_t* pgdir = p->pgdir;
+
   pde_t *d;
   pte_t *pte;
   uint pa, i, flags;
@@ -325,8 +329,15 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
+    if(!(*pte & PTE_P)){
+      // [UPOBIR]
+      //panic("copyuvm: page not present");
+      if(pagefault(p, i) == -1)
+        panic("copyuvm: page fault failed");
+
+      if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+        panic("copyuvm: paged in page should exist");
+    }
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
